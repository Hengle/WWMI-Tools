import hashlib

from typing import List, Dict, Union
from dataclasses import dataclass, field

from ..migoto_io.blender_interface.collections import *
from ..migoto_io.blender_interface.objects import *
from ..migoto_io.blender_interface.mesh import *

from ..migoto_io.buffers.byte_buffer import ByteBuffer

from ..extract_frame_data.metadata_format import ExtractedObject

from .object_merger import MergedObject, SkeletonType
from .metadata_collector import Version, ModInfo
from .texture_collector import Texture
from .ini_builder.IniBuilder import IniBuilder, IniSection, SectionType, IniSectionConditional
    

def is_ini_edited(ini_path):
    '''
    Extracts defined SHA256 CHECKSUM from provided file and calculates sha256 of remaining lines
    If hashes match, it means that file doesn't contain any manual edits
    Allows to detect if mod.ini was manually edited to prevent accidental overwrite
    '''
    with open(ini_path, 'r') as f:
        data = list(f)

        # Extract data from expected location of checksum stamp
        checksum = data[-1].strip()

        # Ensure that checksum stamp has expected prefix 
        checksum_prefix = '; SHA256 CHECKSUM: '
        if not checksum.startswith(checksum_prefix):
            return False
        
        # Extract sha256 hash value from checksum stamp
        sha256 = checksum.replace(checksum_prefix, '')
        
        # Calculate sha256 hash of all lines above checksum stamp
        ini_data = data[:-1]
        ini_sha256 = hashlib.sha256(''.join(ini_data).encode('utf-8')).hexdigest()

        # Check if checksums are matching, different sha256 means data was edited
        if ini_sha256 != sha256:
            return True

        return False


@dataclass
class IniMaker:
    # Input
    mod_info: ModInfo
    extracted_object: ExtractedObject
    merged_object: MergedObject
    output_vertex_count: int
    buffers: Dict[str, ByteBuffer]
    textures: List[Texture]
    comment_code: bool
    # Output
    ini: IniBuilder = field(init=False)

    def __post_init__(self):
        self.ini = IniBuilder({
            'skip_comments': not self.comment_code
        })
        self.ini.header = (
            '; WWMI ALPHA-1 INI\n\n'
        )
        self.make_mod_state_group()
        if self.merged_object.shapekeys.vertex_count > 0:
            self.make_shape_keys_override_group()
        self.make_draw_calls_group()
        self.make_mod_info_group()
        self.make_texture_resources_group()
        self.make_buffer_resources_group()
        if self.merged_object.shapekeys.vertex_count > 0:
            self.make_shape_keys_resources_group()
        if self.merged_object.skeleton_type == SkeletonType.Merged:
            self.make_skeleton_resources_group()
        self.make_autogenerated_group()

    def build(self):
        return self.with_checksum(self.ini.build())
    
    @staticmethod
    def with_checksum(lines):
        '''
        Calculates sha256 hash of provided lines and adds following looking entry to the end:
        '; SHA256 CHECKSUM: 401cafcfdb224c5013802b3dd5a5442df5f082404a9a1fed91b0f8650d604370' + '\n'
        Allows to detect if mod.ini was manually edited to prevent accidental overwrite
        '''
        sha256 = hashlib.sha256(lines.encode('utf-8')).hexdigest()
        lines += f'; SHA256 CHECKSUM: {sha256}' + '\n'
        return lines

    def make_mod_state_group(self):
        self.ini.set_group_header(0, (
            '; Mod State -------------------------\n\n'
        ))

        # [Constants]
        constants = IniSection(
            comment='Global variables used by entire mod',
            name='',
            section_type=SectionType.Constants,
        )
        self.ini.add_section(constants, 0)

        constants.body.add_comment(r'Allows WWMI to safely disable incompatible mod and notify user about it')
        constants.body.add_command(r'global $required_wwmi_version = %.1f' % self.mod_info.required_wwmi_version.as_float())

        constants.body.add_comment(r'Number of indices in original model')
        constants.body.add_command(r'global $object_guid = %d' % self.extracted_object.index_count)

        constants.body.add_comment(r'Number of vertices in custom model')
        constants.body.add_command(f'global $mesh_vertex_count = {self.output_vertex_count}')

        constants.body.add_comment(r'Number of shapekeyed vertices in custom model')
        constants.body.add_command(f'global $shapekey_vertex_count = {self.merged_object.shapekeys.vertex_count}')

        constants.body.add_comment(r'ID assigned to our mod by WWMI')
        constants.body.add_command(r'global $mod_id = -1000')

        if self.merged_object.skeleton_type == SkeletonType.Merged:
            constants.body.add_comment(r'Changes between 0 and 1 with every frame, used to run bone merging only once per frame for every component')
            constants.body.add_command(r'global $state_id = 0')

            constants.body.add_comment(r'Used to count draws of single component to detect duplicate object on screen (not supported with merged skeleton)')
            constants.body.add_command(r'global $draw_counter = 0')

        constants.body.add_comment(r'Controls whether our mod is enabled, prevents any overrides from happening if $mod_enabled == 0')
        constants.body.add_comment(r'Prevents user from being crash-locked in case of incompatible WWMI version')
        constants.body.add_command(r'global $mod_enabled = 0')

        # [Present]
        present = IniSection(
            comment='List of commands executed for every frame',
            name='',
            section_type=SectionType.Present,
        )
        self.ini.add_section(present, 0)

        if self.merged_object.skeleton_type == SkeletonType.Merged:
        
            mod_enabled_condition = present.body.add_command(IniSectionConditional())
            draw_count_body = mod_enabled_condition.add_if_clause('$mod_enabled')
            draw_count_body.add_command('run = CommandListLoadMergedSkeleton')

            # [CommandListLoadMergedSkeleton]
            load_merged_skeleton = IniSection(
                comment='Copes hard to make merged skeleton work with WuWa 1.1 pipeline',
                name='LoadMergedSkeleton',
                section_type=SectionType.CommandList,
            )
            self.ini.add_section(load_merged_skeleton, 0)

            load_merged_skeleton.body.add_command(r'local $last_draw_count')
            load_merged_skeleton.body.add_command(r'local $delay_load')

            draw_count_condition = load_merged_skeleton.body.add_command(IniSectionConditional())
            draw_count_body = draw_count_condition.add_if_clause('$draw_counter > 0')

            draw_count_body.add_comment(r'Changes between 0 and 1 with every frame, used to run bone merging only once per frame for every component')
            state_id_condition = draw_count_body.add_command(IniSectionConditional())
            state_id_if_body = state_id_condition.add_if_clause('$state_id')
            state_id_if_body.add_command(r'$state_id = 0')
            state_id_else_body = state_id_condition.add_else_clause()
            state_id_else_body.add_command(r'$state_id = 1')

            draw_count_body.add_comment(r'Delays load of custom model for 0.5s after entering the Character Menu')
            draw_count_body.add_comment(r'Avoids face glitch (not researched yet)')
            last_draw_count_condition = draw_count_body.add_command(IniSectionConditional())
                
            last_draw_count_if_body = last_draw_count_condition.add_if_clause('$last_draw_count == 0 && $\WWMIv1\in_character_menu')
            last_draw_count_if_body.add_command(r'$delay_load = time + 0.5')

            draw_count_body.add_comment(r'Delays load of custom model for 0.5s if there were more than 1.5x time of expected draw calls')
            draw_count_body.add_comment(r'Avoids skeleton glitch when there are more than one object with modded model on screen')
            component_draw_count_condition = draw_count_body.add_command(IniSectionConditional())

            last_draw_count_if_body = component_draw_count_condition.add_if_clause('$draw_counter > $\WWMIv1\component_draw_calls_count')
            last_draw_count_if_body.add_command(r'$delay_load = time + 0.5')
   
            draw_count_body.add_comment(r'Copy completed merged skeleton from previous frame to override original skeleton with it in current frame')
            copy_skeleton_condition = draw_count_body.add_command(IniSectionConditional())

            copy_skeleton_if_body = copy_skeleton_condition.add_if_clause('$delay_load == 0')
            copy_skeleton_if_body.add_command(r'ResourceMergedSkeleton = copy ResourceMergedSkeletonRW')
            copy_skeleton_else_body = copy_skeleton_condition.add_else_clause()
            copy_skeleton_else_body.add_comment(r'Reset delay variable if current time has higher value')

            reset_delay_condition = copy_skeleton_else_body.add_command(IniSectionConditional())
            reset_delay_if_body = reset_delay_condition.add_if_clause('time > $delay_load')
            reset_delay_if_body.add_command(r'$delay_load = 0')
            copy_skeleton_else_body.add_comment(r'Set merge skeleton to null to signal draw call overrides that they should skip current frame')
            copy_skeleton_else_body.add_command(r'ResourceMergedSkeleton = null')
                    
            draw_count_body.add_command(r'$last_draw_count = $draw_counter')
            draw_count_body.add_command(r'$draw_counter = 0')

            draw_count_elif_body = draw_count_condition.add_elif_clause('$last_draw_count != 0')
            draw_count_elif_body.add_comment(r'Object is not detected, cleanup resources and variables')
            reset_merged_skeleton_condition = draw_count_elif_body.add_command(IniSectionConditional())
            reset_merged_skeleton_condition_if_body = reset_merged_skeleton_condition.add_if_clause('ResourceMergedSkeleton !== null')
            reset_merged_skeleton_condition_if_body.add_command(r'ResourceMergedSkeleton = null')
            draw_count_elif_body.add_command(r'$last_draw_count = 0')

    def make_mod_info_group(self):
        self.ini.set_group_header(1, (
            '; Resources: Mod Info -------------------------\n\n'
        ))

        # [ResourceModName]
        mod_name = IniSection(
            comment='Name of mod',
            name='ModName',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(mod_name, 1)

        if len(self.mod_info.mod_name.strip()) != 0:
            mod_name.body.add_command(r'type = Buffer')
            mod_name.body.add_command(f'data = "{self.mod_info.mod_name}"')
        else:
            mod_name.body.add_persistent_comment(r'type = Buffer')
            mod_name.body.add_persistent_comment(f'data = "Unknown Mod Name"')

        # [ResourceModAuthor]
        mod_author = IniSection(
            comment='Name of mod author',
            name='ModAuthor',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(mod_author, 1)

        if len(self.mod_info.mod_author.strip()) != 0:
            mod_author.body.add_command(r'type = Buffer')
            mod_author.body.add_command(f'data = "{self.mod_info.mod_author}"')
        else:
            mod_author.body.add_persistent_comment(r'type = Buffer')
            mod_author.body.add_persistent_comment(f'data = "Unknown Mod Author"')

        # [ResourceModDesc]
        mod_desc = IniSection(
            comment='Mod description',
            name='ModDesc',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(mod_desc, 1)

        if len(self.mod_info.mod_desc.strip()) != 0:
            mod_desc.body.add_command(r'type = Buffer')
            mod_desc.body.add_command(f'data = "{self.mod_info.mod_desc}"')
        else:
            mod_desc.body.add_persistent_comment(r'type = Buffer')
            mod_desc.body.add_persistent_comment(f'data = "Empty Mod Description"')

        # [ResourceModLink]
        mod_link = IniSection(
            comment='Link to mod repository',
            name='ModLink',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(mod_link, 1)

        if len(self.mod_info.mod_link.strip()) != 0:
            mod_link.body.add_command(r'type = Buffer')
            mod_link.body.add_command(f'data = "{self.mod_info.mod_link}"')
        else:
            mod_link.body.add_persistent_comment(r'type = Buffer')
            mod_link.body.add_persistent_comment(f'data = "Empty Mod Link"')

        # [ResourceModLogo]
        mod_logo = IniSection(
            comment='Texture file with 512x512 .dds (BC7 SRGB) mod logo',
            name='ModLogo',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(mod_logo, 1)

        if self.mod_info.mod_logo.is_file():
            mod_logo.body.add_command(r'filename = Textures/Logo.dds')
        else:
            mod_logo.body.add_persistent_comment(r'filename = Textures/Logo.dds')

    def make_draw_calls_group(self):
        self.ini.set_group_header(2, (
            '; Shading: Draw Call Stacks Processing -------------------------\n\n'
        ))

        # [CommandListRegisterMod]
        register_mod = IniSection(
            comment='Contacts WWMI to check whether installed version is compatible with our mod',
            name='RegisterMod',
            section_type=SectionType.CommandList,
        )
        self.ini.add_section(register_mod, 2)

        register_mod.body.add_comment(r'Pass mod info variables to WWMI')
        register_mod.body.add_command(r'$\WWMIv1\required_wwmi_version = $required_wwmi_version')
        register_mod.body.add_command(r'$\WWMIv1\object_guid = $object_guid')

        register_mod.body.add_comment(r'Pass mod info resources to WWMI')
        register_mod.body.add_command(r'Resource\WWMIv1\ModName = ref ResourceModName')
        register_mod.body.add_command(r'Resource\WWMIv1\ModAuthor = ref ResourceModAuthor')
        register_mod.body.add_command(r'Resource\WWMIv1\ModDesc = ref ResourceModDesc')
        register_mod.body.add_command(r'Resource\WWMIv1\ModLink = ref ResourceModLink')
        register_mod.body.add_command(r'Resource\WWMIv1\ModLogo = ref ResourceModLogo')

        register_mod.body.add_comment(r'Register mod in WWMI')
        register_mod.body.add_command(r'run = CommandList\WWMIv1\RegisterMod')

        register_mod.body.add_comment(r'Read mod_id assigned to our mod by WWMI, incompatible mod will get `$mod_id == -1` assigned')
        register_mod.body.add_command(r'$mod_id = $\WWMIv1\mod_id')

        register_mod.body.add_comment(r'Enable our mod if WWMI assigned valid $mod_id to it')
        valid_mod_id_condition = register_mod.body.add_command(IniSectionConditional())
        valid_mod_id_body = valid_mod_id_condition.add_if_clause('$mod_id >= 0')
        valid_mod_id_body.add_command(r'$mod_enabled = 1')

        if self.merged_object.skeleton_type == SkeletonType.Merged:

            # [TextureOverrideMarkBoneDataCB]
            mark_bone_data_cb = IniSection(
                comment='Marks Bones Data CB resource with arbitrary value 3381.7777',
                name='MarkBoneDataCB',
                section_type=SectionType.TextureOverride,
                hash=self.extracted_object.cb4_hash,
            )
            self.ini.add_section(mark_bone_data_cb, 2)
            mark_bone_data_cb.body.add_command(r'match_priority = 0')
            mark_bone_data_cb.body.add_command(r'filter_index = 3381.7777')

            # [CommandListMergeSkeleton]
            merge_skeleton = IniSection(
                comment='Update ResourceMergedSkeletonRW with bones data of current component',
                name='MergeSkeleton',
                section_type=SectionType.CommandList,
            )
            self.ini.add_section(merge_skeleton, 2)
       
            merge_skeleton.body.add_comment(r'Pass constant buffer with bone data to copy bones from')
            merge_skeleton.body.add_command(r'cs-cb8 = ref vs-cb4')
            merge_skeleton.body.add_comment(r'Pass buffer that gonna store bone data of all components')
            merge_skeleton.body.add_command(r'cs-u6 = ResourceMergedSkeletonRW')
            merge_skeleton.body.add_comment(r'Set custom scale for entire model')
            merge_skeleton.body.add_command(r'$\WWMIv1\custom_mesh_scale = 1.0')
            merge_skeleton.body.add_comment(r'Run Skeleton Merger CS to merge bones of current component into ResourceMergedSkeletonRW')
            merge_skeleton.body.add_command(r'run = CustomShader\WWMIv1\SkeletonMerger')

        # [CommandListOverrideSharedResources]
        replace_shared_resources = IniSection(
            comment='Overrides resources that are shared between VS calls',
            name='OverrideSharedResources',
            section_type=SectionType.CommandList,
        )
        self.ini.add_section(replace_shared_resources, 2)
        replace_shared_resources.body.add_comment(r'Override resources to make draw calls use custom meshes')
        replace_shared_resources.body.add_command(r'ib = ResourceIndexBuffer')
        replace_shared_resources.body.add_command(r'vb0 = ResourcePositionBuffer')
        replace_shared_resources.body.add_command(r'vb1 = ResourceVectorBuffer')
        replace_shared_resources.body.add_command(r'vb2 = ResourceTexcoordBuffer')
        replace_shared_resources.body.add_command(r'vb3 = ResourceColorBuffer')
        replace_shared_resources.body.add_command(r'vb4 = ResourceBlendBuffer')

        if self.merged_object.skeleton_type == SkeletonType.Merged:

            replace_shared_resources.body.add_comment(r'Pass merged skeleton is resource matches marked Bones Data CB')

            cb3_condition = replace_shared_resources.body.add_command(IniSectionConditional())
            cb3_if_body = cb3_condition.add_if_clause('vs-cb3 == 3381.7777')
            cb3_if_body.add_command(r'vs-cb3 = ResourceMergedSkeleton')

            cb4_condition = replace_shared_resources.body.add_command(IniSectionConditional())
            cb4_if_body = cb4_condition.add_if_clause('vs-cb4 == 3381.7777')
            cb4_if_body.add_command(r'vs-cb4 = ResourceMergedSkeleton')

        # [CommandListOverrideTextures]
        replace_textures = IniSection(
            comment='Overrides textures via triggering [ResourceTextureX] sections by calling chechtextureoverride on ps-t slots',
            name='OverrideTextures',
            section_type=SectionType.CommandList,
        )
        self.ini.add_section(replace_textures, 2)

        replace_textures.body.add_command(r'checktextureoverride = ps-t0')
        replace_textures.body.add_command(r'checktextureoverride = ps-t1')
        replace_textures.body.add_command(r'checktextureoverride = ps-t2')
        replace_textures.body.add_command(r'checktextureoverride = ps-t3')
        replace_textures.body.add_command(r'checktextureoverride = ps-t4')
        replace_textures.body.add_command(r'checktextureoverride = ps-t5')
        replace_textures.body.add_command(r'checktextureoverride = ps-t6')
        replace_textures.body.add_command(r'checktextureoverride = ps-t7')

        for component_id, component in enumerate(self.extracted_object.components):

            extracted_component = self.extracted_object.components[component_id]
            
            # [TextureOverrideComponentX]
            replace_component = IniSection(
                comment=f'Override draw calls for Component {component_id}',
                name=f'Component{component_id}',
                section_type=SectionType.TextureOverride,
                hash=self.extracted_object.cb4_hash,
            )
            self.ini.add_section(replace_component, 2)
            replace_component.body.add_command(f'match_first_index = {component.index_offset}')
            replace_component.body.add_command(f'match_index_count = {component.index_count}')
            
            if component_id == 0:
                replace_component.body.add_comment(r'Check if our mod is compatible with installed WWMI version (runs only once)')
                mod_id_condition = replace_component.body.add_command(IniSectionConditional())
                mod_id_body = mod_id_condition.add_if_clause('$mod_id == -1000')

                mod_id_body.add_comment(r'Pass required WWMI version along with mod metadata to WWMI')
                mod_id_body.add_command(r'run = CommandListRegisterMod')
            
            mod_enabled_condition = replace_component.body.add_command(IniSectionConditional())
            mod_enabled_body = mod_enabled_condition.add_if_clause('$mod_enabled')

            if self.merged_object.skeleton_type == SkeletonType.Merged:
                mod_enabled_body.add_command(f'local $state_id_{component_id}')
                if component_id == 0:
                    mod_enabled_body.add_command(r'$draw_counter = $draw_counter + 1')
                mod_enabled_body.add_comment(r'Limit bone merging to 1 time per frame')
                merge_bones_condition = mod_enabled_body.add_command(IniSectionConditional())
                merge_bones_condition_body = merge_bones_condition.add_if_clause(f'$state_id_{component_id} != $state_id')
                merge_bones_condition_body.add_comment(r'$state_id changes between 0 and 1 every frame')
                merge_bones_condition_body.add_command(f'$state_id_{component_id} = $state_id')
                merge_bones_condition_body.add_comment(r'Pass variables for SkeletonMerger CS')
                merge_bones_condition_body.add_command(r'$\WWMIv1\vg_offset = %d' % extracted_component.vg_offset)
                merge_bones_condition_body.add_command(r'$\WWMIv1\vg_count = %d' % extracted_component.vg_count)
                merge_bones_condition_body.add_comment(r'Merge bones of this components into ResourceMergedSkeleton')
                merge_bones_condition_body.add_command(r'run = CommandListMergeSkeleton')

                mod_enabled_body.add_comment(r'Override draw call if we have merged skeleton ready')
                override_draw_call_condition = mod_enabled_body.add_command(IniSectionConditional())
                # Here we redifine mod_enabled_body to make next ini maker calls write into merged skelly condtition
                mod_enabled_body = override_draw_call_condition.add_if_clause('ResourceMergedSkeleton !== null')


            mod_enabled_body.add_comment(r'Skip original draw call')
            mod_enabled_body.add_command(r'handling = skip')
            
            mod_enabled_body.add_comment(r'Override shared resources')
            mod_enabled_body.add_command(f'run = {replace_shared_resources.get_section_title()}')

            mod_enabled_body.add_comment(r'Override textures')
            mod_enabled_body.add_command(f'run = {replace_textures.get_section_title()}')

            custom_component = self.merged_object.components[component_id]
            if len(custom_component.objects) > 0:
                for obj in custom_component.objects:
                    mod_enabled_body.add_persistent_comment(f'Draw {obj.name}')
                    mod_enabled_body.add_command(f'drawindexed = {obj.index_count}, {obj.index_offset}, 0')
            else:
                mod_enabled_body.add_persistent_comment(f'Draw skipped: No matching custom components found')

    def make_texture_resources_group(self):
        self.ini.set_group_header(3, (
            '; Shading: Textures -------------------------\n\n'
        ))

        for texture_id, texture in enumerate(self.textures):

            texture_resoruce = IniSection(
                name=f'Texture{texture_id}',
                section_type=SectionType.Resource,
            )
            self.ini.add_section(texture_resoruce, 3)

            texture_resoruce.body.add_command(f'filename = Textures/{texture.filename}')

            texture_override = IniSection(
                name=f'Texture{texture_id}',
                hash=texture.hash,
                section_type=SectionType.TextureOverride,
            )
            self.ini.add_section(texture_override, 3)

            texture_override.body.add_command(f'match_priority = 0')
            texture_override.body.add_command(f'this = {texture_resoruce.get_section_title()}')

    def make_shape_keys_override_group(self):
        self.ini.set_group_header(4, (
            '; Skinning: Shape Keys Override -------------------------\n\n'
        ))
        
        # [TextureOverrideVertexLimitRaiseShapeKeyOffsets]
        raise_shape_key_offsets = IniSection(
            comment='Increases size of UAV that stores shapekeyed vertices xyz offsets to support more vertices than original',
            name='VertexLimitRaiseShapeKeyOffsets',
            section_type=SectionType.TextureOverride,
            hash=self.extracted_object.shapekeys.offsets_hash,
        )
        self.ini.add_section(raise_shape_key_offsets, 4)

        raise_shape_key_offsets.body.add_command(r'match_priority = 0')
                
        # [TextureOverrideVertexLimitRaiseShapeKeyScale]
        raise_shape_key_scale = IniSection(
            comment='Increases size of UAV that stores shapekeyed vertices multipliers to support more vertices than original',
            name='VertexLimitRaiseShapeKeyScale',
            section_type=SectionType.TextureOverride,
            hash=self.extracted_object.shapekeys.scale_hash,
        )
        self.ini.add_section(raise_shape_key_scale, 4)

        raise_shape_key_scale.body.add_command(r'match_priority = 0')

        
        # [CommandListSetupShapeKeys]
        setup_shapekeys = IniSection(
            comment='Updates ResourceShapeKeyCBRW that stores offsets of shapekeyed vertex lists, shape key values and multipliers',
            name='SetupShapeKeys',
            section_type=SectionType.CommandList,
        )
        self.ini.add_section(setup_shapekeys, 4)

        setup_shapekeys.body.add_comment(r'Pass 4 byte checksum of shapekey offsets to ensure that we only modify expected values')
        setup_shapekeys.body.add_command(f'$\WWMIv1\shapekey_checksum = {self.extracted_object.shapekeys.checksum}')
        setup_shapekeys.body.add_comment(r'Pass buffer with offsets for vertex lists of every shape key of custom model')
        setup_shapekeys.body.add_command(r'cs-t33 = ResourceShapeKeyOffsetBuffer')
        setup_shapekeys.body.add_comment(r'Pass buffer with custom values for every shape key, allows to control both custom and stock')
        setup_shapekeys.body.add_command(r'cs-u5 = ResourceCustomShapeKeyValuesRW')
        setup_shapekeys.body.add_comment(r'Pass buffer that gonna store result of calculations, required for Shape Key Loader CS to run')
        setup_shapekeys.body.add_command(r'cs-u6 = ResourceShapeKeyCBRW')

        setup_shapekeys.body.add_comment(r'Run ShapeKeyOverrider CS')
        setup_shapekeys.body.add_command(r'run = CustomShader\WWMIv1\ShapeKeyOverrider')
        
        # [CommandListLoadShapeKeys]
        load_shapekeys = IniSection(
            comment='Runs custom Shape Key Loader CS to, well, load shapekeys data from buffers',
            name='LoadShapeKeys',
            section_type=SectionType.CommandList,
        )
        self.ini.add_section(load_shapekeys, 4)

        load_shapekeys.body.add_comment(r'Pass number of shapekeyed vertices to adjust required threads count via dipatch_y')
        load_shapekeys.body.add_command(f'$\WWMIv1\shapekey_vertex_count = $shapekey_vertex_count')

        load_shapekeys.body.add_comment(r'Pass buffer with lists of per-vertex ids for every shape key')
        load_shapekeys.body.add_command(r'cs-t0 = ResourceShapeKeyVertexIdBuffer')
        load_shapekeys.body.add_comment(r'Pass buffer with lists of xyz per-vertex offsets for every shape key')
        load_shapekeys.body.add_command(r'cs-t1 = ResourceShapeKeyVertexOffsetBuffer')
        load_shapekeys.body.add_comment(r'Pass buffer with shape key vertex lists offsets, and shape key values & multipliers')
        load_shapekeys.body.add_command(r'cs-u6 = ResourceShapeKeyCBRW')

        load_shapekeys.body.add_comment(r'Run ShapeKeyLoader CS')
        load_shapekeys.body.add_command(r'run = CustomShader\WWMIv1\ShapeKeyLoader')

        # [TextureOverrideShapeKeyLoaderCallback]
        loader_cs_callback = IniSection(
            comment='Handles WWMI callback fired on original Shape Key Loader CS call',
            name='ShapeKeyLoaderCallback',
            section_type=SectionType.TextureOverride,
            hash=self.extracted_object.shapekeys.offsets_hash,
        )
        self.ini.add_section(loader_cs_callback, 4)

        loader_cs_callback.body.add_command(r'match_priority = 0')

        mod_enabled_condition = loader_cs_callback.body.add_command(IniSectionConditional())
        mod_enabled_body = mod_enabled_condition.add_if_clause('$mod_enabled')

        mod_enabled_body.add_comment(r'Ensure that callback has WWMI filter_index of Shape Key Loader CS assigned')
        loader_callback_condition = mod_enabled_body.add_command(IniSectionConditional())
        if self.merged_object.skeleton_type == SkeletonType.Merged:
            loader_cs_body = loader_callback_condition.add_if_clause('cs == 3381.3333 && ResourceMergedSkeleton !== null')
        else:
            loader_cs_body = loader_callback_condition.add_if_clause('cs == 3381.3333')

        # It looks like we can skip checking for THREAD_GROUP_COUNT_Y as UAV hashes are unique for each object
        # loader_cs_body.add_comment(r'Ensure that dispatch_y of Shape Key Loader CS call matches one from dump')
        # run_loader_condition = loader_cs_body.add_command(IniSectionConditional())
        # run_loader_body = run_loader_condition.add_if_clause(f'THREAD_GROUP_COUNT_Y == {self.shapekeys.loader_dispatch_y}')
        loader_cs_body.add_comment(r'Skip handling of original Shape Key Loader CS call to modify dispatch_y value')
        loader_cs_body.add_command(r'handling = skip')
        loader_cs_body.add_comment(r'Run custom Shape Key Overrider CS to prepare shape key resources for loading')
        loader_cs_body.add_command(f'run = {setup_shapekeys.get_section_title()}')
        loader_cs_body.add_comment(r'Run custom Shape Key Loader CS to load shape key resources')
        loader_cs_body.add_command(f'run = {load_shapekeys.get_section_title()}')

        # [CommandListMultiplyShapeKeys]
        multiply_shapekeys = IniSection(
            comment='Runs custom Shape Key Loader CS to, well, load shapekeys data from buffers',
            name='MultiplyShapeKeys',
            section_type=SectionType.CommandList,
        )
        self.ini.add_section(multiply_shapekeys, 4)
        multiply_shapekeys.body.add_comment(r'Pass number of shapekeyed vertices to adjust required threads count via dipatch_y')
        multiply_shapekeys.body.add_command(r'$\WWMIv1\shapekey_vertex_count = $shapekey_vertex_count')
        multiply_shapekeys.body.add_comment(r'Run custom Shape Key Multiplier CS to set deformation intensity')
        multiply_shapekeys.body.add_command(r'run = CustomShader\WWMIv1\ShapeKeyMultiplier')

        # [TextureOverrideShapeKeyMultiplierCallback]
        multiplier_cs_callback = IniSection(
            comment='Handles WWMI callback fired on original Shape Key Multiplier CS call',
            name='ShapeKeyMultiplierCallback',
            section_type=SectionType.TextureOverride,
            hash=self.extracted_object.shapekeys.offsets_hash,
        )
        self.ini.add_section(multiplier_cs_callback, 4)

        multiplier_cs_callback.body.add_command(r'match_priority = 0')

        mod_enabled_condition = multiplier_cs_callback.body.add_command(IniSectionConditional())
        mod_enabled_body = mod_enabled_condition.add_if_clause('$mod_enabled')

        mod_enabled_body.add_comment(r'Ensure that callback has WWMI filter_index of Shape Key Multiplier CS assigned')
        multiplier_callback_condition = mod_enabled_body.add_command(IniSectionConditional())
        
        if self.merged_object.skeleton_type == SkeletonType.Merged:
            multiplier_cs_body = multiplier_callback_condition.add_if_clause('cs == 3381.4444 && ResourceMergedSkeleton !== null')
        else:
            multiplier_cs_body = multiplier_callback_condition.add_if_clause('cs == 3381.4444')

        # It looks like we can skip checking for THREAD_GROUP_COUNT_Y as UAV hashes are unique for each object
        # multiplier_cs_body.add_comment(r'Ensure that dispatch_y of Shape Key Multiplier CS call matches one from dump')
        # multiplier_condition = multiplier_cs_body.add_command(IniSectionConditional())
        # run_multiplier_body = multiplier_condition.add_if_clause(f'THREAD_GROUP_COUNT_Y == {self.shapekeys.multiplier_dispatch_y}')
        multiplier_cs_body.add_comment(r'Skip handling of original Shape Key Multiplier CS call to modify dispatch_y value')
        multiplier_cs_body.add_command(r'handling = skip')
        multiplier_cs_body.add_comment(r'Run custom Shape Key Multiplier CS to apply dynamic per-character multipliers')
        multiplier_cs_body.add_command(f'run = {multiply_shapekeys.get_section_title()}')

    def make_buffer_resources_group(self):
        self.ini.set_group_header(6, (
            '; Resources: Buffers -------------------------\n\n'
        ))

        for buffer_name, buffer in self.buffers.items():

            buffer_resource = IniSection(
                name=f'{buffer_name}Buffer',
                section_type=SectionType.Resource,
            )
            self.ini.add_section(buffer_resource, 6)
            buffer_resource.body.add_command(r'type = Buffer')
            buffer_resource.body.add_command(f'format = {buffer.layout.semantics[0].get_format()}')
            buffer_resource.body.add_command(f'stride = {buffer.layout.stride}')
            buffer_resource.body.add_command(f'filename = Meshes/{buffer_name}.buf')
   
    def make_shape_keys_resources_group(self):
        self.ini.set_group_header(7, (
            '; Resources: Shape Keys Override -------------------------\n\n'
        ))

        # [ResourceShapeKeyCBRW]
        shapekey_cb = IniSection(
            comment='Stores dynamically calculated CB required to override original Shape Keys CS call',
            name='ShapeKeyCBRW',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(shapekey_cb, 7)
        shapekey_cb.body.add_comment(r'Contains 128+128+8 values:')
        shapekey_cb.body.add_comment(r'* 128 uint: Shape Key offsets (continuous lists of vertex offsets)')
        shapekey_cb.body.add_comment(r'* 128 unorm: Shape Key values (range [0.0, 1.0])')
        shapekey_cb.body.add_comment(r'* 8 uint: Shape Key CS settings')
        shapekey_cb.body.add_command(r'type = RWBuffer')
        shapekey_cb.body.add_command(r'format = R32G32B32A32_UINT')
        shapekey_cb.body.add_comment(r'32 shapekey offsets, 32 shapekey values, 2 control flags')
        shapekey_cb.body.add_command(r'array = 66')

        # [ResourceCustomShapeKeyValuesRW]
        custom_values = IniSection(
            comment='Stores values of custom Shape Keys and overrides for original ones',
            name='CustomShapeKeyValuesRW',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(custom_values, 7)
        custom_values.body.add_comment(r'Contains 128 values, zero is shifted by 1.0 to the right')
        custom_values.body.add_comment(r'Expected value range is [1.0, 2.0]')
        custom_values.body.add_comment(r'* `0.0` means `no override`')
        custom_values.body.add_comment(r'* `1.0` means `override with zero`')
        custom_values.body.add_comment(r'* `2.0` means `override with one`')
        custom_values.body.add_command(r'type = RWBuffer')
        custom_values.body.add_command(r'format = R32G32B32A32_FLOAT')
        custom_values.body.add_comment(r'32 elements, 4 floats per element')
        custom_values.body.add_command(r'array = 32')

    def make_skeleton_resources_group(self):
        self.ini.set_group_header(8, (
            '; Resources: Skeleton Override -------------------------\n\n'
        ))

        # [ResourceMergedSkeleton]
        merged_skeleton = IniSection(
            comment='Stores a copy of full skeleton merged in previous frame',
            name='MergedSkeleton',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(merged_skeleton, 8)

        # [ResourceMergedSkeletonRW]
        merged_skeleton = IniSection(
            comment='Stores merged skeleton consisting of bones from all components, allows to make VG weights global',
            name='MergedSkeletonRW',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(merged_skeleton, 8)

        merged_skeleton.body.add_comment(r'Contains up to 256 bones')
        merged_skeleton.body.add_command(r'type = RWBuffer')
        merged_skeleton.body.add_command(r'format = R32G32B32A32_FLOAT')
        merged_skeleton.body.add_comment(r'256 bones, 3 elements per bone, 4 floats per element')
        merged_skeleton.body.add_command(r'array = 768')

    def make_autogenerated_group(self):
        msg = 'This mod.ini was automatically generated by WWMI Tools Blender addon v%s and requires WWMI v%s+ to function' % (
            self.mod_info.wwmi_tools_version, self.mod_info.required_wwmi_version
        )
        self.ini.set_group_footer(8, (
            '\n'
            '; Autogenerated -------------------------\n'
            '\n'
            f'; {msg}' + '\n'
            '; WWMI Link: https://gamebanana.com/mods/xxxxxx' + '\n'
            '; WWMI GitHub: https://github.com/SpectrumQT/WWMI' + '\n'
            '; WWMI Tools Link: https://gamebanana.com/mods/xxxxxx' + '\n'
            '; WWMI Tools GitHub: https://github.com/SpectrumQT/WWMI_Tools' + '\n'
            '; AGMG Modding Community Discord: https://discord.com/invite/agmg' + '\n'
            '\n'
        ))
    
